# Cursor AI Context Instructions - AI Stock Analyzer App

## Project Overview

You are helping build an AI-powered stock analysis and prediction app called "AI Stock Analyzer". This is a full-stack application with a React Native mobile app, Python/FastAPI backend, and machine learning models for stock analysis and prediction.

## Core Functionality

- Analyze stocks using AI/ML models (fundamental + technical + sentiment analysis)
- Predict stock price movements (short-term and long-term)
- Provide personalized stock recommendations based on user risk profiles
- Portfolio optimization and risk assessment
- Real-time market data integration
- News sentiment analysis

## Tech Stack

### Frontend (Mobile)

- **Framework**: React Native (with Expo)
- **Navigation**: React Navigation v6
- **State Management**: Redux Toolkit + RTK Query
- **UI Components**: React Native Elements + Custom themed components
- **Charts**: react-native-svg-charts or Victory Native
- **Forms**: React Hook Form
- **Authentication**: React Native App Auth
- **Push Notifications**: Expo Notifications

### Backend

- **Framework**: Python FastAPI
- **Database**: PostgreSQL (main) + MongoDB (unstructured data)
- **ORM**: SQLAlchemy
- **Cache**: Redis
- **Queue**: Celery + RabbitMQ
- **ML Models**: TensorFlow/PyTorch models served via separate service
- **WebSocket**: For real-time price updates
- **Authentication**: JWT tokens with refresh mechanism

### Infrastructure

- **Cloud**: Railway
- **Container**: Docker + Kubernetes
- **CI/CD**: GitHub Actions
- **Monitoring**: Prometheus + Grafana
- **Logging**: ELK Stack

## Project Structure

```
ai-stock-analyzer/
├── mobile/                    # React Native app
│   ├── src/
│   │   ├── components/       # Reusable UI components
│   │   ├── screens/         # Screen components
│   │   ├── navigation/      # Navigation configuration
│   │   ├── services/        # API services
│   │   ├── store/          # Redux store
│   │   ├── utils/          # Helper functions
│   │   ├── hooks/          # Custom React hooks
│   │   └── constants/      # App constants
│   └── app.json
├── backend/                  # FastAPI backend
│   ├── app/
│   │   ├── api/            # API endpoints
│   │   ├── core/           # Core functionality
│   │   ├── models/         # Database models
│   │   ├── schemas/        # Pydantic schemas
│   │   ├── services/       # Business logic
│   │   ├── ml/            # ML integration
│   │   └── utils/         # Utilities
│   └── requirements.txt
├── ml-service/              # ML model service
│   ├── models/             # Trained models
│   ├── training/           # Training scripts
│   ├── preprocessing/      # Data preprocessing
│   └── serving/           # Model serving
└── docker-compose.yml
```

## Key Components to Implement

### Mobile App Components

1. **AuthStack**: Login, Register, ForgotPassword screens
2. **MainStack**: Dashboard, StockDetail, Portfolio, Search, Profile
3. **StockCard**: Displays stock info with mini chart
4. **PredictionChart**: Shows AI predictions with confidence bands
5. **RiskAssessment**: Visual risk indicators
6. **NewsCard**: Sentiment-analyzed news items
7. **PortfolioOptimizer**: Interactive portfolio allocation

### Backend Endpoints

```python
# Core API endpoints
POST   /api/auth/register
POST   /api/auth/login
POST   /api/auth/refresh
GET    /api/stocks/search
GET    /api/stocks/{symbol}
GET    /api/stocks/{symbol}/analysis
GET    /api/stocks/{symbol}/prediction
POST   /api/portfolio/optimize
GET    /api/user/watchlist
POST   /api/user/watchlist
DELETE /api/user/watchlist/{symbol}
GET    /api/news/{symbol}
WS     /ws/prices  # WebSocket for real-time prices
```

### Database Schema (PostgreSQL)

```sql
-- Users table
users: id, email, password_hash, risk_profile, created_at, updated_at

-- Stocks table
stocks: symbol, name, sector, market_cap, last_updated

-- User watchlists
watchlists: user_id, stock_symbol, added_at

-- Predictions
predictions: id, stock_symbol, prediction_date, predicted_price, confidence, model_version

-- Portfolio
portfolios: user_id, stock_symbol, quantity, purchase_price, purchase_date
```

### ML Model Integration Pattern

```python
# Always use this pattern for ML predictions
async def get_prediction(symbol: str):
    # 1. Fetch latest data
    data = await fetch_stock_data(symbol)

    # 2. Preprocess
    features = preprocess_data(data)

    # 3. Get predictions from multiple models
    predictions = {
        'lstm': lstm_model.predict(features),
        'random_forest': rf_model.predict(features),
        'ensemble': ensemble_predict(features)
    }

    # 4. Calculate confidence
    confidence = calculate_confidence(predictions)

    # 5. Return structured response
    return PredictionResponse(
        symbol=symbol,
        predictions=predictions,
        confidence=confidence,
        metadata=metadata
    )
```

## Coding Standards & Patterns

### React Native Standards

- Use functional components with hooks exclusively
- Implement proper TypeScript types for all props and state
- Use React.memo for performance optimization
- Always handle loading and error states
- Implement proper pull-to-refresh on lists
- Use React Native's Platform API for platform-specific code

### Python/FastAPI Standards

- Use async/await for all database and external API calls
- Implement proper error handling with custom exceptions
- Use Pydantic for request/response validation
- Follow PEP 8 style guide
- Write comprehensive docstrings
- Use dependency injection for services

### Common Patterns

1. **API Calls**: Always use RTK Query for data fetching
2. **Authentication**: Store tokens securely in Keychain/Keystore
3. **Error Handling**: Centralized error boundary + toast notifications
4. **Data Validation**: Validate on both client and server
5. **Caching**: Implement smart caching with RTK Query
6. **Offline Support**: Queue actions when offline

## Security Considerations

- Never store sensitive data in AsyncStorage
- Always use HTTPS for API calls
- Implement certificate pinning for production
- Sanitize all user inputs
- Use prepared statements for SQL queries
- Implement rate limiting on all endpoints
- Log security events for monitoring

## Performance Guidelines

- Lazy load screens and components
- Implement virtualized lists for large datasets
- Use React Native Fast Image for image caching
- Optimize bundle size with dynamic imports
- Cache API responses appropriately
- Use WebSocket for real-time data instead of polling

## Testing Strategy

- Unit tests for all utility functions
- Integration tests for API endpoints
- Component testing with React Native Testing Library
- E2E tests with Detox
- ML model performance tests
- Load testing for WebSocket connections

## Common Code Snippets

### API Service Pattern

```typescript
// services/stockApi.ts
export const stockApi = createApi({
  reducerPath: 'stockApi',
  baseQuery: fetchBaseQuery({
    baseUrl: API_BASE_URL,
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      if (token) headers.set('authorization', `Bearer ${token}`);
      return headers;
    },
  }),
  tagTypes: ['Stock', 'Watchlist', 'Portfolio'],
  endpoints: (builder) => ({
    getStock: builder.query<Stock, string>({
      query: (symbol) => `stocks/${symbol}`,
      providesTags: ['Stock'],
    }),
  }),
});
```

### Screen Component Pattern

```typescript
// screens/StockDetailScreen.tsx
export const StockDetailScreen: React.FC<Props> = ({ route }) => {
  const { symbol } = route.params;
  const { data, isLoading, error } = useGetStockQuery(symbol);

  if (isLoading) return <LoadingScreen />;
  if (error) return <ErrorScreen error={error} />;

  return (
    <SafeAreaView style={styles.container}>
      <StockHeader stock={data} />
      <PredictionChart predictions={data.predictions} />
      <RiskIndicator risk={data.riskScore} />
    </SafeAreaView>
  );
};
```

## Testing Requirements & Patterns

### CRITICAL: Test-Driven Development (TDD)

**EVERY feature must have tests written FIRST before implementation**

- Minimum 80% code coverage required
- No PR can be merged without tests
- Tests must be fast - mock all external dependencies

### Frontend Testing Setup

```json
// package.json test scripts
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "detox test --configuration ios.release",
    "test:e2e:android": "detox test --configuration android.release"
  }
}
```

### Test File Structure

```
mobile/
├── __tests__/
│   ├── setup.js              // Jest setup file
│   ├── unit/                 // Pure function tests
│   ├── components/           // Component tests
│   ├── screens/             // Screen integration tests
│   ├── hooks/               // Custom hook tests
│   ├── services/            // API service tests
│   └── fixtures/            // Shared test data
├── e2e/                     // Detox E2E tests
└── __mocks__/               // Module mocks
```

### Component Test Pattern

```typescript
// ALWAYS write tests like this for EVERY component
// __tests__/components/StockCard.test.tsx
import React from 'react';
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import { Provider } from 'react-redux';
import { StockCard } from '../../src/components/StockCard';
import { mockStore } from '../setup';

describe('StockCard', () => {
  const defaultProps = {
    stock: {
      symbol: 'AAPL',
      name: 'Apple Inc.',
      price: 150.0,
      change: 2.5,
      changePercent: 1.69,
    },
    onPress: jest.fn(),
  };

  // Helper function for rendering with providers
  const renderComponent = (props = {}) => {
    return render(
      <Provider store={mockStore()}>
        <StockCard {...defaultProps} {...props} />
      </Provider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render stock information correctly', () => {
    const { getByText, getByTestId } = renderComponent();

    expect(getByText('AAPL')).toBeTruthy();
    expect(getByText('Apple Inc.')).toBeTruthy();
    expect(getByText('$150.00')).toBeTruthy();
    expect(getByTestId('price-change')).toHaveTextContent('+2.50');
  });

  it('should handle press events', () => {
    const { getByTestId } = renderComponent();

    fireEvent.press(getByTestId('stock-card-touchable'));
    expect(defaultProps.onPress).toHaveBeenCalledWith('AAPL');
  });
});
```

### Screen Test Pattern

```typescript
// EVERY screen must have integration tests
// __tests__/screens/StockDetailScreen.test.tsx
describe('StockDetailScreen', () => {
  it('should load and display all data sections', async () => {
    const { getByText, getByTestId } = renderScreen(
      <StockDetailScreen route={{ params: { symbol: 'AAPL' } }} />
    );

    // Check loading state
    expect(getByTestId('loading-indicator')).toBeTruthy();

    // Wait for data
    await waitFor(() => {
      expect(getByText('Apple Inc.')).toBeTruthy();
    });

    // Verify all sections rendered
    expect(getByText('Price Prediction')).toBeTruthy();
    expect(getByText('Technical Analysis')).toBeTruthy();
    expect(getByText('Risk Assessment')).toBeTruthy();
  });
});
```

### Hook Test Pattern

```typescript
// Custom hooks MUST be tested in isolation
// __tests__/hooks/useStockData.test.ts
import { renderHook, waitFor } from '@testing-library/react-native';
import { useStockData } from '../../src/hooks/useStockData';

describe('useStockData', () => {
  it('should fetch and return stock data', async () => {
    const { result } = renderHook(() => useStockData('AAPL'));

    expect(result.current.isLoading).toBe(true);

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.data).toMatchObject({
      symbol: 'AAPL',
      price: expect.any(Number),
    });
  });
});
```

### API Service Test Pattern

```typescript
// Test all API calls with MSW
// __tests__/services/stockApi.test.ts
import { stockApi } from '../../src/services/stockApi';
import { server } from '../mocks/server';
import { rest } from 'msw';

describe('stockApi', () => {
  it('should handle API errors gracefully', async () => {
    server.use(
      rest.get('/api/stocks/:symbol', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );

    await expect(stockApi.getStock('AAPL')).rejects.toThrow('Server error');
  });
});
```

### Backend Test Pattern

```python
# EVERY endpoint needs comprehensive tests
# tests/api/test_stock_endpoints.py
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
class TestStockEndpoints:
    async def test_get_stock_analysis(self, client: AsyncClient, auth_headers: dict):
        """Test stock analysis endpoint with all edge cases."""
        # Success case
        response = await client.get("/api/stocks/AAPL/analysis", headers=auth_headers)
        assert response.status_code == 200
        assert "fundamental_score" in response.json()

        # Not found case
        response = await client.get("/api/stocks/INVALID/analysis", headers=auth_headers)
        assert response.status_code == 404

        # Unauthorized case
        response = await client.get("/api/stocks/AAPL/analysis")
        assert response.status_code == 401
```

### ML Model Test Pattern

```python
# ML models need performance and accuracy tests
# tests/ml/test_prediction_model.py
class TestPredictionModel:
    def test_prediction_accuracy(self, test_data):
        """Ensure model meets minimum accuracy threshold."""
        model = StockPredictor()
        predictions = model.predict(test_data.features)
        accuracy = calculate_accuracy(predictions, test_data.labels)
        assert accuracy >= 0.75  # 75% minimum accuracy

    def test_prediction_confidence_bounds(self):
        """Verify confidence intervals are reasonable."""
        predictions = model.predict_with_confidence(features)
        for pred in predictions:
            assert pred.lower_bound < pred.predicted < pred.upper_bound
            assert 0 <= pred.confidence <= 1
```

### E2E Test Pattern (Detox)

```typescript
// e2e/criticalUserFlows.e2e.ts
describe('Critical User Flows', () => {
  beforeAll(async () => {
    await device.launchApp({ newInstance: true });
  });

  it('should complete stock purchase flow', async () => {
    // Login
    await element(by.id('email-input')).typeText('test@example.com');
    await element(by.id('password-input')).typeText('password');
    await element(by.id('login-button')).tap();

    // Search and select stock
    await element(by.id('search-button')).tap();
    await element(by.id('search-input')).typeText('AAPL');
    await element(by.text('AAPL - Apple Inc.')).tap();

    // Verify analysis loaded
    await waitFor(element(by.id('prediction-chart')))
      .toBeVisible()
      .withTimeout(5000);

    // Make purchase
    await element(by.id('buy-button')).tap();
    await element(by.id('quantity-input')).typeText('10');
    await element(by.id('confirm-purchase')).tap();

    // Verify in portfolio
    await element(by.id('portfolio-tab')).tap();
    await expect(element(by.text('AAPL'))).toBeVisible();
  });
});
```

### Test Data Fixtures

```typescript
// __tests__/fixtures/stocks.ts
export const mockStocks = {
  AAPL: {
    symbol: 'AAPL',
    name: 'Apple Inc.',
    price: 150.0,
    change: 2.5,
    changePercent: 1.69,
    marketCap: 2500000000000,
    sector: 'Technology',
  },
  GOOGL: {
    symbol: 'GOOGL',
    name: 'Alphabet Inc.',
    price: 2800.0,
    change: -15.0,
    changePercent: -0.53,
    marketCap: 1800000000000,
    sector: 'Technology',
  },
};

// __tests__/fixtures/predictions.ts
export const mockPredictions = {
  AAPL: {
    symbol: 'AAPL',
    predictions: Array.from({ length: 7 }, (_, i) => ({
      date: new Date(Date.now() + i * 24 * 60 * 60 * 1000).toISOString(),
      predictedPrice: 150 + (Math.random() * 10 - 5),
      confidence: 0.75 - i * 0.05,
      upperBound: 155,
      lowerBound: 145,
    })),
  },
};
```

### Mock Service Worker Setup

```typescript
// __tests__/mocks/handlers.ts
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/stocks/:symbol', (req, res, ctx) => {
    const { symbol } = req.params;
    return res(ctx.json(mockStocks[symbol] || null));
  }),

  rest.get('/api/stocks/:symbol/prediction', (req, res, ctx) => {
    const { symbol } = req.params;
    return res(ctx.json(mockPredictions[symbol] || null));
  }),

  // Add handlers for ALL endpoints
];
```

### Testing Commands for Development

```bash
# Run tests in watch mode during development
npm test:watch

# Run tests with coverage before committing
npm test:coverage

# Run E2E tests before merging
npm run test:e2e

# Backend tests
pytest --cov=app --cov-report=html

# Run specific test file
npm test StockCard.test.tsx
pytest tests/api/test_stock_endpoints.py::TestStockEndpoints::test_get_stock_success

# Pre-commit hook (add to .git/hooks/pre-commit)
#!/bin/bash
npm test -- --coverage --watchAll=false
if [ $? -ne 0 ]; then
  echo "Tests failed! Fix before committing."
  exit 1
fi
```

## Development Workflow with Tests

1. **ALWAYS write tests FIRST** (TDD approach)
2. Create feature branch from develop
3. Write failing tests for the feature
4. Implement code to make tests pass
5. Refactor while keeping tests green
6. Run full test suite before committing
7. Ensure coverage remains above 80%
8. Update API documentation
9. Create PR with all tests passing

### TDD Example Workflow

```bash
# 1. Create test file first
touch src/components/__tests__/StockPredictionChart.test.tsx

# 2. Write failing test
# StockPredictionChart.test.tsx
it('should render prediction data as a line chart', () => {
  const { getByTestId } = render(<StockPredictionChart data={mockData} />);
  expect(getByTestId('prediction-line')).toBeTruthy();
}); # This will fail - component doesn't exist

# 3. Create component file
touch src/components/StockPredictionChart.tsx

# 4. Implement minimal code to pass test
# 5. Add more tests and features incrementally
# 6. Refactor once all tests pass
```

## CI/CD Test Requirements

```yaml
# .github/workflows/test.yml
name: Test Suite
on: [push, pull_request]

jobs:
  frontend-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Run Jest tests
        run: npm test -- --coverage --ci
      - name: Check coverage
        run: |
          coverage=$(cat coverage/coverage-summary.json | jq '.total.lines.pct')
          if [ $coverage -lt 80 ]; then exit 1; fi

  backend-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Run pytest
        run: pytest --cov=app --cov-fail-under=80
```

Remember:

- **NO CODE WITHOUT TESTS** - This is a financial app where bugs cost money
- Tests are not optional - they're part of the feature
- If you can't test it, refactor until you can
- Mock external dependencies (APIs, databases, etc.)
- Test edge cases, not just happy paths
- Performance tests for critical paths

## Why Testing is CRITICAL for This App

1. **Financial Accuracy**: Incorrect predictions or calculations can lead to financial losses
2. **Security**: Vulnerabilities can expose user financial data
3. **Reliability**: Users depend on real-time data - downtime costs trust
4. **Compliance**: Financial apps have regulatory requirements
5. **User Trust**: One bug showing wrong portfolio value destroys credibility

### Critical Areas Requiring Extra Testing

- Price calculations and currency formatting
- Portfolio value calculations
- ML prediction accuracy and confidence bounds
- Authentication and authorization
- Payment processing
- Real-time data synchronization
- Data encryption and security

### Performance Testing Requirements

```typescript
// Performance tests for critical components
// __tests__/performance/StockList.perf.test.tsx
import { measurePerformance } from '@testing-library/react-native-performance';

test('StockList renders 1000 items under 16ms', async () => {
  const scenario = async () => {
    renderWithProviders(<StockList stocks={generate1000Stocks()} />);
  };

  const { meanDuration } = await measurePerformance(scenario);
  expect(meanDuration).toBeLessThan(16); // 60fps threshold
});

// Backend performance test
// tests/performance/test_api_performance.py
@pytest.mark.performance
async def test_stock_analysis_response_time(client):
    start = time.time()
    response = await client.get("/api/stocks/AAPL/analysis")
    duration = time.time() - start

    assert response.status_code == 200
    assert duration < 0.5  # 500ms max response time
```

### Load Testing (Locust)

```python
# locustfile.py
from locust import HttpUser, task, between

class StockAnalyzerUser(HttpUser):
    wait_time = between(1, 3)

    @task(3)
    def view_stock(self):
        self.client.get("/api/stocks/AAPL")

    @task(2)
    def get_prediction(self):
        self.client.get("/api/stocks/AAPL/prediction")

    @task(1)
    def portfolio_optimization(self):
        self.client.post("/api/portfolio/optimize", json={
            "stocks": ["AAPL", "GOOGL", "MSFT"],
            "risk_tolerance": "moderate"
        })

# Run: locust -f locustfile.py --host=http://localhost:8000
```
